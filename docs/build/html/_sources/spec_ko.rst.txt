콘다 패키지 사양
===========================

.. contents::

콘다 패키지는 bzip 으로 압축된 tar 아카이브로 ``info/`` 디렉토리 하의 메타데이터들과
install prefix 로 바로 설치된 파일들을 포함한다. 콘다 패키지의 형식은 모든 플랫폼과 운영체제에서 동일하다.
설치 과정에서 ``info/`` 의 파일을 제외한 모든 파일은 기본적으로 install prefix 로 추출되므로 주의한다.
간단히 말해 환경에 콘다 패키지를 설치하는 것은 아래 커맨드를 실행하는 것이라고 할 수 있다.::

   $ cd <environment prefix>
   $ tar xjf some-package-1.0-0.tar.bz2

그러나 심볼릭 링크를 포함한 파일들만이 콘다 패키지의 일부이고 디렉토리는 콘다 패키지에 속하지 않는다는 것을 알아두자.
디렉토리는 필요에 따라 생성되거나 삭제되지만 tar 아카이브에 빈 디렉토리를 생성하는건 불가능하다.

아래에서 ``info/`` 디렉토리에 포함되는 메타데이터들의 정확한 형식과 이 메타데이터들이
저장소 인덱스 (``repodata.json.bz``) 와 어떻게 연관되는지에 대해 다룰 것이다.

.. _package_metadata:

패키지 메타데이터
----------------

패키지에 대한 모든 메타데이터는 ``info/`` 에 위치한다. ``info/`` 의 파일들은 install prefix 로 설치되지 않는다. 패키지 작성자는 어떤 파일이든 추가할 수 있지만 콘다는 아래 나열된 파일의 내용만을 검사한다.:

``info/index.json``: 이 파일은 패키지명, 버전, 빌드 문자열, 하위요소와 같이 패키지에 대한 기본적인 정보를 포함한다.
이 파일의 내용은 저장소 인덱스 파일인 ``repodata.json`` 에 저장된다. (``index.json`` 에도 저장)
json 객체는 아래 키들을 포함하는 딕셔너리 형식이다.:

   ``name``: 문자열
      소문자로 된 패키지명. 이 문자열은 ``-`` 를 포함할 수 있다.

   ``version``: 문자열
      패키지 버전으로 ``-`` 를 포함하지 않을 수 있다.
      콘다는 `PEP 440 <https://www.python.org/dev/peps/pep-0440/>`_ 를 승인한다.

   ``build``: 문자열
      빌드 문자열로 ``-`` 를 포함하지 않을 수 있다.
      콘다 패키지의 파일명은 이 세가지 값으로 구성되어 아래와 같이 나타난다.
      ``<name>-<version>-<build>.tar.bz2``.

   ``build_number``: 정수
      패키지의 빌드 번호를 나타내는 정수. 음수는 될 수 없다.

   ``depends``: 문자열 리스트
      하위요소 사양 리스트.
      각각의 요소는 :ref:`build-version-spec` 에 정리된 대로 작성한 문자열이다.

   ``arch``: 문자열 (선택)
      콘다를 위해 빌드된 아키텍처 패키지. (예시 ``x86_64``)
      콘다는 현재 이 키를 사용하지 않는다.

   ``platform``: 문자열 (선택)
      콘다를 위해 빌드된 플랫폼 (OS) 패키지. (예시 ``osx``)
      콘다는 현재 이 키를 사용하지 않는다.
      특정한 아키텍처와 플랫폼을 위한 패키지는 일반적으로 패키지가 속하는 저장소의 하위 디렉토리로 구별된다.

빌드 문자열은 동일한 명칭과 버전의 패키지를 구별하기 위해 사용한다.
빌드 문자열을 사용하는 예시로는 명칭과 버전은 동일하지만 다른 하위 요소(파이썬 3.4와 파이썬2.7),
빌드 과정에서의 버그 수정, 다른 선택적 하위 요소(MKL과 ATLAS linkage) 등이 있다.
콘다는 빌드 문자열을 조사하진 않는다. ``np18py34_1`` 와 같은 문자열은 사람이 구별하기 쉽도록 고안된 것이다.

빌드 문자열과 달리 콘다는 빌드 번호를 조사한다. 빌드 번호는 패키지를 분류하고 최신 버전을 구별하는데 사용된다.
(동일한 명칭과 버전의 패키지들 간에)
새로운 빌드가 저장소에 추가되어야 한다는 점(버그 수정)에서 때문에 빌드 번호는 중요한 정보이다.

``info/files``: 이 파일은 패키지 자체를 구성하는 파일을 모두 나열한다. (한 줄에 하나씩)
예를 들어 환경에 링크하기 위해 필요한 모든 파일들.
이 파일에 나열되지 않은 파일은 패키지가 설치될 때 링크되지 않는다.
``info/files`` 내부의 파일을 위한 디렉토리 식별자는 ``/`` 를 사용한다. (윈도우 포함)
이 식별자는 tarball 에서 사용하는 디렉토리 식별자와 일치한다.

``info/has_prefix``: 이 선택 파일은 하드 코드 된 빌드 접두사 또는 플레이스홀더 접두사를 포함한다.
이는 설치시 install prefix 로 대체된다. 바이너리 대체가 작동하는 방식으로 인해
플레이스홀더 접두사는 install prefix 보다 길어선 안된다.

이 파일의 각 줄은 경로 또는 공백으로 구별되는 리스트가 될 수 있다. 경로일 경우에는 디폴트 플레이스홀더에 의해 텍스트 파일로 간주된다.
리스트는 ``placeholder``, ``mode``, ``path`` 로 구성된다. ``placeholder`` 가 빌드 또는 플레이스홀더 접두사가 된다.
``mode`` 는 ``text``와 ``binary`` 모두 될 수 있고 ``path`` 는 업데이트 될 파일의 상대 경로이다.
아래 예시는 OS X 또는 리눅스의 예시이다.

::

   bin/script.sh
   /Users/username/anaconda/envs/_build binary bin/binary
   /Users/username/anaconda/envs/_build text share/text

윈도우라면 아래와 같다.

::

  "Scripts/script1.py"
  "C:\Users\username\anaconda\envs\_build" text "Scripts/script2.bat"
  "C:/Users/username/anaconda/envs/_build" binary "Scripts/binary"

상대 경로를 위한 디렉토리 식별자는 윈도우일지라도 반드시 ``/`` 가 되어야 한다.
플레이스 홀더는 ``\`` 또는 윈도우라면 ``/`` 가 된다. 대체 접두사는 플레이스 홀더의 식별자와 동일하다.
(디폴트 플레이스 홀더 ``/opt/anaconda1anaconda2anaconda3`` 는 예외이며
네거티브 경로 식별자를 사용하는 install prefix 로 대체된다.)
윈도우에서 ``placeholder`` 와 ``path`` 는 공백을 포함하는 경로를 지원하기 위해 "인용" 으로 나타낸다.

``info/license.txt``: 이 선택 파일은 패키지의 소프트웨어 라이센스이다.

``info/no_link``: 이 선택 파일은 환경에 링크될 수 없는 파일을 나열한다.
소프트 링크와 하드 링크 모두 포함하며 이 파일들은 링크되는 대신 복사된다.

``info/about.json``: 이 선택 파일은 :doc:`./building/meta-yaml_ko` 파일의 :ref:`about` 섹션 내부 항목들을 포함한다.
빌드 레시피에 존재하는 아래 키들이 ``info/about.json`` 에 추가된다.

::

  home
  dev_url
  doc_url
  license_url
  license
  summary
  description
  license_family

``info/recipe``: 이 디렉토리는 빌드 레시피의 모든 내용을 포함한다.

    ``meta.yaml.rendered``: 완전히 렌더링 빌드 레시피이다. :doc:`../commands/build/conda-render_ko` 를 보자.

    이 디렉토리는 :ref:`meta-build` 의 ``include_recipe`` 플래그가 True 일 때만 존재한다.


스크립트 링크와 링크 해제
------------------------

몇개의 스크립트는 선택적으로 링크와 링크 해제 단계 전후에 실행된다.
이 스크립트들은 콘다의 하위 프로세스에서 실행되고
``/bin/bash <script>`` (유닉스) 또는 ``%COMSPEC% /c <script>`` (윈도우) 를 사용한다.
이를 위해 스크립트의 파일명과 경로에 대한 규칙이 필요하다.
``bin/.<name>-<action>.sh`` (유닉스), ``Scripts/.<name>-<action>.bat`` (윈도우) 가 있고
``<name>`` 은 패키지명이고 ``<action>`` 은 아래 나열된 것들 중 하나가 된다.:

``pre-link``: 링크에 앞서 실행되고 콘다를 중단시키는 에러이다.

``post-link``: 링크 뒤에 실행되고 post-link 가 실패한다면 패키지 메타데이터를 작성하지 않고 돌아온다.
이로 인해 패키지는 설치되지 않은 것으로 간주된다.

``pre-unlink``: 링크 해제에 앞서 실행되고 무시되는 에러이다.

예를 들어, ``foo-1.0-0.tar.bz2`` 패키지 내부에 ``/bin/.foo-post-link.sh`` 라는 명칭의 스크립트가 있다면
링크가 완료된 이후에 실행된다. 더 나아사 다음 환경 변수들이 스크립트가 실행되는 도중 설정된다.:
``PREFIX``, ``PKG_NAME``, ``PKG_VERSION``


저장소 구조와 인덱스
------------------------------

콘다 저장소 (또는 채널)은 디렉토리 계층으로 주로 HTTPS로 제공된다.
디렉토리 계층은 플랫폼 하위 디렉토리를 가지고 있으며 각각의 디렉토리는 콘다 패키지와 저장소 인덱스를 갖는다.
인덱스 파일 ``repodata.json`` 은 플랫폼 하위 디렉토리 내부의 모든 콘다 패키지를 나열한다.
``conda index`` 커맨드는 디렉토리 내부의 콘다 패키지로부터 인덱스를 생성하는데 사용될 수 있다.
이는 앞서 다룬 ``info/index.json`` 내부의 딕셔너리 객체로 완전한 콘다 패키지 파일명을 매핑하는 단순한 작업이다.

다음 예시에서 저장소는 64-bit 리눅스와 32-bit 윈도우 상의 콘다 패키지 ``misc-1.0-np17py27_0.tar.bz2`` 를 제공한다.::

   <some path>/linux-64/repodata.json
                        repodata.json.bz2
                        misc-1.0-np17py27_0.tar.bz2
              /win-32/repodata.json
                      repodata.json.bz2
                      misc-1.0-np17py27_0.tar.bz2

두개의 콘다 패키지는 동일한 파일명을 갖고 패키지가 속한 저장소의 하위 디렉토리에 의해서만 구별 가능하다는 것을 알아두자.

.. _build-version-spec:

패키지 매치 표준
----------------------------

conda install 커맨드에서 사용하는 문법과 다르다는 것을 알아두자.
(``conda install python=3.4`` 와 같은 커맨드 라인과 다르다.)
내부적으로 콘다는 커맨드 라인 문법을 아래 정의된 표준으로 해석한다.
예를 들어, ``python=3.4`` 는 ``python 3.4*`` 로 해석된다.

패키지 하위요소들은 매치 표준에 따라 명시된다. 매치 표준은 공백으로 구분되는 문자열로 많게는 3개의 부분으로 나뉜다.

* 첫번째 부분은 항상 정확한 패키지 명칭이다.
* 두번째 부분은 버전을 나타내며 특수 문자를 포함할 수 있다.

  ``|`` 는 "or" 을 의미한다. 예를 들어, ``1.0|1.2`` 는 1.0 버전 또는 1.2 버전을 의미한다.

  ``*`` 는 버전 문자열 내부의 0개 이상의 문자를 의미한다.
  표준 표현식에서 ``r'.*'`` 와 동일하다.

  예를 들어, ``1.0|1.4*``  는 1.0, 1.4, 1.4.1b2 를 의미하고 1.2 는 될 수 없다.

  ``<``, ``>``, ``<=``, ``>=``, ``==``, ``!=`` 버전의 관계 연산자로
  `PEP-440 <https://www.python.org/dev/peps/pep-0440/>`_ 를 사용하여 비교한다.
  예를 들어, ``<=1.0`` 는 ``0.9``, ``0.9.1``, ``1.0`` 가 될 수 있고 ``1.0.1`` 는 될 수 없다.
  ``==`` 과 ``!=`` 등호가 된다.
  
  사전 배포 버전은 ``>1.0b4`` 와 같은 형식을 지원한다.
  이는 ``1.0b5``, ``1.0rc1`` 는 될 수 있고 ``1.0b4`` 와 ``1.0a5`` 는 될 수 없다.

  ``,`` 는 "and" 를 의미한다. 예를 들어, ``>=2,<3`` 는 "2" 시리즈의 모든 패키지와 매치된다.
  ``2.0``, ``2.1``, ``2.9`` 모두 될 수 있고 ``3.0`` 과 ``1.0`` 는 될 수 없다.

  ``,`` 는 ``|`` 보다 높은 우선순위를 갖는다. 예를 들어, ``>=1,<2|>3`` 는 "(1 이상 and 2 미만) or
  (3 초과)," 를 의미한다. ``1``, ``1.3``, ``3.0`` 는 매치되고 ``2.2`` 는 매치되지 않는다.

  콘다는 ``|`` 로 구별되는 부분들로 나누는 방식으로 버전을 파싱한다.
  만약 부분이 ``<``, ``>``, ``=``, ``!`` 중 하나로 시작한다면, 관계 연산자로 파싱된다.
  아닌 경우엔 ``*`` 연산자를 포함하는 방식으로 파싱될 수 있다.

* 세번째 부분은 항상 정확한 빌드 문자열이다. 세번째 부분이 있다면 두번째 부분은 패지지의 정확한 버전이 되어야 한다.

버전 표준은 공백을 포함해선 안된다는 점을 기억하자. 전체 매치 표준에서 공백은 패키지, 버전, 빌드 문자열의 구별자로 사용되기 때문이다.
``python >= 2.7`` 는 매치 표준으로 인식될 수 없다. 추가로 ``python>=2.7`` 는 "python>=2.7" 인 모든 버전이 된다.

커맨드 라인을 사용할 때 패키지 버전 표준에 `` `` (공백), ``<``, ``>``, ``*``, ``|`` 이 포함되면
아래와 같이 쌍따옴표 인용을 사용한다.::

    conda install numpy=1.11
    conda install numpy==1.11
    conda install "numpy>1.11"
    conda install "numpy=1.11.1|1.11.3"
    conda install "numpy>=1.8,<2"

예시
~~~~~~~~

"OR" 제한조건 ``"numpy=1.11.1|1.11.3"`` 는 1.11.1 또는 1.11.3 과 매치된다.

"AND" 제한조건 ``"numpy>=1.8,<2"`` 는 1.8 과 1.9 에 매치되고 2.0 은 매치되지 않는다.

"fuzzy" 제한조건 ``numpy=1.11`` 은 1.11, 1.11.0, 1.11.1, 1.11.2,
1.11.18 등과 매치된다.

"exact" 재한조건 ``numpy==1.11`` 는 1.11, 1.11.0, 1.11.0.0 등과 매치된다.

빌드 문자열 제한조건 ``"numpy=1.11.2=*nomkl*"`` 는 MKL 이 아닌 NumPy 1.11.2 패키지와 매치된다.
알번 MKL NumPy 1.11.2 패키지와는 매치되지 않는다.

빌드 문자열 제한조건 ``"numpy=1.11.1|1.11.3=py36_0"`` 는 파이썬 3.6의 NumPy 1.11.1 또는 1.11.3 과 매치된다.
파이썬 2.7 또는 3.5 버전을 사용한 어떤 Numpy 와도 매치되지 않는다.

numpy-1.8.1-py27_0 은 다음 제한조건들과 매치된다.:

- ``numpy``
- ``numpy 1.8*``
- ``numpy 1.8.1``
- ``numpy >=1.8``
- ``numpy ==1.8.1``
- ``numpy 1.8|1.8*``
- ``numpy >=1.8,<2``
- ``numpy >=1.8,<2|1.9``
- ``numpy 1.8.1 py27_0``
- ``numpy=1.8.1=py27_0``
